-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Data.Gerber.GerberAST.Par where
import Data.Gerber.GerberAST.Abs
import Data.Gerber.GerberAST.Lex
import Data.Gerber.GerberAST.ErrM

}

%name pCommands Commands
%name pCommand Command
%name pExtendedCommandInside ExtendedCommandInside
%name pListCommand ListCommand
%name pListExtendedCommandInside ListExtendedCommandInside
%name pCommand1 Command1
%name pCommand2 Command2
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '%' { PT _ (TS _ 1) }
  '(' { PT _ (TS _ 2) }
  ')' { PT _ (TS _ 3) }
  '*' { PT _ (TS _ 4) }

L_Generic { PT _ (T_Generic $$) }
L_UIdent { PT _ (T_UIdent $$) }
L_LIdent { PT _ (T_LIdent $$) }


%%

Generic    :: { Generic} : L_Generic { Generic ($1)}
UIdent    :: { UIdent} : L_UIdent { UIdent ($1)}
LIdent    :: { LIdent} : L_LIdent { LIdent ($1)}

Commands :: { Commands }
Commands : ListCommand { Data.Gerber.GerberAST.Abs.Program (reverse $1) }
Command :: { Command }
Command : Generic '*' { Data.Gerber.GerberAST.Abs.SingleStandardCommand $1 }
        | '%' Generic '*' '%' { Data.Gerber.GerberAST.Abs.SingleExtendedCommand $2 }
        | '%' ListExtendedCommandInside '%' { Data.Gerber.GerberAST.Abs.MultiExtendedCommands $2 }
        | Command1 { $1 }
ExtendedCommandInside :: { ExtendedCommandInside }
ExtendedCommandInside : Generic '*' { Data.Gerber.GerberAST.Abs.Troll $1 }
ListCommand :: { [Command] }
ListCommand : {- empty -} { [] }
            | ListCommand Command { flip (:) $1 $2 }
ListExtendedCommandInside :: { [ExtendedCommandInside] }
ListExtendedCommandInside : ExtendedCommandInside { (:[]) $1 }
                          | ExtendedCommandInside ListExtendedCommandInside { (:) $1 $2 }
Command1 :: { Command }
Command1 : Command2 { $1 }
Command2 :: { Command }
Command2 : '(' Command ')' { $2 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    t:_ -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

