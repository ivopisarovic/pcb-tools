-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Data.Gerber.Par where
import Data.Gerber.Abs
import Data.Gerber.Lex
import Data.Gerber.ErrM

}

%name pProgram Program
%name pStm Stm
%name pExp Exp
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '!' { PT _ (TS _ 1) }
  '!=' { PT _ (TS _ 2) }
  '%' { PT _ (TS _ 3) }
  '%=' { PT _ (TS _ 4) }
  '&' { PT _ (TS _ 5) }
  '&&' { PT _ (TS _ 6) }
  '&=' { PT _ (TS _ 7) }
  '(' { PT _ (TS _ 8) }
  ')' { PT _ (TS _ 9) }
  '*' { PT _ (TS _ 10) }
  '*=' { PT _ (TS _ 11) }
  '+' { PT _ (TS _ 12) }
  '++' { PT _ (TS _ 13) }
  '+=' { PT _ (TS _ 14) }
  ',' { PT _ (TS _ 15) }
  '-' { PT _ (TS _ 16) }
  '--' { PT _ (TS _ 17) }
  '-=' { PT _ (TS _ 18) }
  '->' { PT _ (TS _ 19) }
  '.' { PT _ (TS _ 20) }
  '...' { PT _ (TS _ 21) }
  '/' { PT _ (TS _ 22) }
  '/=' { PT _ (TS _ 23) }
  ':' { PT _ (TS _ 24) }
  ';' { PT _ (TS _ 25) }
  '<' { PT _ (TS _ 26) }
  '<<' { PT _ (TS _ 27) }
  '<<=' { PT _ (TS _ 28) }
  '<=' { PT _ (TS _ 29) }
  '=' { PT _ (TS _ 30) }
  '==' { PT _ (TS _ 31) }
  '>' { PT _ (TS _ 32) }
  '>=' { PT _ (TS _ 33) }
  '>>' { PT _ (TS _ 34) }
  '>>=' { PT _ (TS _ 35) }
  '?' { PT _ (TS _ 36) }
  'Typedef_name' { PT _ (TS _ 37) }
  '[' { PT _ (TS _ 38) }
  ']' { PT _ (TS _ 39) }
  '^' { PT _ (TS _ 40) }
  '^=' { PT _ (TS _ 41) }
  '__BEGIN_PROGRAM' { PT _ (TS _ 42) }
  '__END_PROGRAM' { PT _ (TS _ 43) }
  'auto' { PT _ (TS _ 44) }
  'break' { PT _ (TS _ 45) }
  'case' { PT _ (TS _ 46) }
  'char' { PT _ (TS _ 47) }
  'const' { PT _ (TS _ 48) }
  'continue' { PT _ (TS _ 49) }
  'default' { PT _ (TS _ 50) }
  'do' { PT _ (TS _ 51) }
  'double' { PT _ (TS _ 52) }
  'else' { PT _ (TS _ 53) }
  'enum' { PT _ (TS _ 54) }
  'extern' { PT _ (TS _ 55) }
  'float' { PT _ (TS _ 56) }
  'for' { PT _ (TS _ 57) }
  'goto' { PT _ (TS _ 58) }
  'if' { PT _ (TS _ 59) }
  'int' { PT _ (TS _ 60) }
  'long' { PT _ (TS _ 61) }
  'register' { PT _ (TS _ 62) }
  'return' { PT _ (TS _ 63) }
  'short' { PT _ (TS _ 64) }
  'signed' { PT _ (TS _ 65) }
  'sizeof' { PT _ (TS _ 66) }
  'static' { PT _ (TS _ 67) }
  'struct' { PT _ (TS _ 68) }
  'switch' { PT _ (TS _ 69) }
  'typedef' { PT _ (TS _ 70) }
  'union' { PT _ (TS _ 71) }
  'unsigned' { PT _ (TS _ 72) }
  'void' { PT _ (TS _ 73) }
  'volatile' { PT _ (TS _ 74) }
  'while' { PT _ (TS _ 75) }
  '{' { PT _ (TS _ 76) }
  '|' { PT _ (TS _ 77) }
  '|=' { PT _ (TS _ 78) }
  '||' { PT _ (TS _ 79) }
  '}' { PT _ (TS _ 80) }
  '~' { PT _ (TS _ 81) }

L_ident  { PT _ (TV $$) }
L_quoted { PT _ (TL $$) }
L_doubl  { PT _ (TD $$) }
L_charac { PT _ (TC $$) }
L_integ  { PT _ (TI $$) }
L_Unsigned { PT _ (T_Unsigned $$) }
L_Long { PT _ (T_Long $$) }
L_UnsignedLong { PT _ (T_UnsignedLong $$) }
L_Hexadecimal { PT _ (T_Hexadecimal $$) }
L_HexUnsigned { PT _ (T_HexUnsigned $$) }
L_HexLong { PT _ (T_HexLong $$) }
L_HexUnsLong { PT _ (T_HexUnsLong $$) }
L_Octal { PT _ (T_Octal $$) }
L_OctalUnsigned { PT _ (T_OctalUnsigned $$) }
L_OctalLong { PT _ (T_OctalLong $$) }
L_OctalUnsLong { PT _ (T_OctalUnsLong $$) }
L_CDouble { PT _ (T_CDouble $$) }
L_CFloat { PT _ (T_CFloat $$) }
L_CLongDouble { PT _ (T_CLongDouble $$) }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
String  :: { String }  : L_quoted {  $1 }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }
Char    :: { Char }    : L_charac { (read ( $1)) :: Char }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Unsigned    :: { Unsigned} : L_Unsigned { Unsigned ($1)}
Long    :: { Long} : L_Long { Long ($1)}
UnsignedLong    :: { UnsignedLong} : L_UnsignedLong { UnsignedLong ($1)}
Hexadecimal    :: { Hexadecimal} : L_Hexadecimal { Hexadecimal ($1)}
HexUnsigned    :: { HexUnsigned} : L_HexUnsigned { HexUnsigned ($1)}
HexLong    :: { HexLong} : L_HexLong { HexLong ($1)}
HexUnsLong    :: { HexUnsLong} : L_HexUnsLong { HexUnsLong ($1)}
Octal    :: { Octal} : L_Octal { Octal ($1)}
OctalUnsigned    :: { OctalUnsigned} : L_OctalUnsigned { OctalUnsigned ($1)}
OctalLong    :: { OctalLong} : L_OctalLong { OctalLong ($1)}
OctalUnsLong    :: { OctalUnsLong} : L_OctalUnsLong { OctalUnsLong ($1)}
CDouble    :: { CDouble} : L_CDouble { CDouble ($1)}
CFloat    :: { CFloat} : L_CFloat { CFloat ($1)}
CLongDouble    :: { CLongDouble} : L_CLongDouble { CLongDouble ($1)}

Program :: { Program }
Program : '__BEGIN_PROGRAM' ListExternal_declaration '__END_PROGRAM' { Data.Gerber.Abs.Progr (reverse $2) }
External_declaration :: { External_declaration }
External_declaration : Function_def { Data.Gerber.Abs.Afunc $1 }
                     | Dec { Data.Gerber.Abs.Global $1 }
Function_def :: { Function_def }
Function_def : ListDeclaration_specifier Declarator ListDec Compound_stm { Data.Gerber.Abs.OldFunc $1 $2 $3 $4 }
             | ListDeclaration_specifier Declarator Compound_stm { Data.Gerber.Abs.NewFunc $1 $2 $3 }
             | Declarator ListDec Compound_stm { Data.Gerber.Abs.OldFuncInt $1 $2 $3 }
             | Declarator Compound_stm { Data.Gerber.Abs.NewFuncInt $1 $2 }
Dec :: { Dec }
Dec : ListDeclaration_specifier ';' { Data.Gerber.Abs.NoDeclarator $1 }
    | ListDeclaration_specifier ListInit_declarator ';' { Data.Gerber.Abs.Declarators $1 $2 }
ListDec :: { [Dec] }
ListDec : Dec { (:[]) $1 } | Dec ListDec { (:) $1 $2 }
ListDeclaration_specifier :: { [Declaration_specifier] }
ListDeclaration_specifier : Declaration_specifier { (:[]) $1 }
                          | Declaration_specifier ListDeclaration_specifier { (:) $1 $2 }
Declaration_specifier :: { Declaration_specifier }
Declaration_specifier : Type_specifier { Data.Gerber.Abs.Type $1 }
                      | Storage_class_specifier { Data.Gerber.Abs.Storage $1 }
                      | Type_qualifier { Data.Gerber.Abs.SpecProp $1 }
ListInit_declarator :: { [Init_declarator] }
ListInit_declarator : Init_declarator { (:[]) $1 }
                    | Init_declarator ',' ListInit_declarator { (:) $1 $3 }
Init_declarator :: { Init_declarator }
Init_declarator : Declarator { Data.Gerber.Abs.OnlyDecl $1 }
                | Declarator '=' Initz { Data.Gerber.Abs.InitDecl $1 $3 }
Type_specifier :: { Type_specifier }
Type_specifier : 'void' { Data.Gerber.Abs.Tvoid }
               | 'char' { Data.Gerber.Abs.Tchar }
               | 'short' { Data.Gerber.Abs.Tshort }
               | 'int' { Data.Gerber.Abs.Tint }
               | 'long' { Data.Gerber.Abs.Tlong }
               | 'float' { Data.Gerber.Abs.Tfloat }
               | 'double' { Data.Gerber.Abs.Tdouble }
               | 'signed' { Data.Gerber.Abs.Tsigned }
               | 'unsigned' { Data.Gerber.Abs.Tunsigned }
               | Struct_or_union_spec { Data.Gerber.Abs.Tstruct $1 }
               | Enum_specifier { Data.Gerber.Abs.Tenum $1 }
               | 'Typedef_name' { Data.Gerber.Abs.Tname }
Storage_class_specifier :: { Storage_class_specifier }
Storage_class_specifier : 'typedef' { Data.Gerber.Abs.MyType }
                        | 'extern' { Data.Gerber.Abs.GlobalPrograms }
                        | 'static' { Data.Gerber.Abs.LocalProgram }
                        | 'auto' { Data.Gerber.Abs.LocalBlock }
                        | 'register' { Data.Gerber.Abs.LocalReg }
Type_qualifier :: { Type_qualifier }
Type_qualifier : 'const' { Data.Gerber.Abs.Const }
               | 'volatile' { Data.Gerber.Abs.NoOptim }
Struct_or_union_spec :: { Struct_or_union_spec }
Struct_or_union_spec : Struct_or_union Ident '{' ListStruct_dec '}' { Data.Gerber.Abs.Tag $1 $2 (reverse $4) }
                     | Struct_or_union '{' ListStruct_dec '}' { Data.Gerber.Abs.Unique $1 (reverse $3) }
                     | Struct_or_union Ident { Data.Gerber.Abs.TagType $1 $2 }
Struct_or_union :: { Struct_or_union }
Struct_or_union : 'struct' { Data.Gerber.Abs.Struct }
                | 'union' { Data.Gerber.Abs.Union }
Struct_dec :: { Struct_dec }
Struct_dec : ListSpec_qual ListStruct_declarator ';' { Data.Gerber.Abs.Structen $1 $2 }
ListSpec_qual :: { [Spec_qual] }
ListSpec_qual : Spec_qual { (:[]) $1 }
              | Spec_qual ListSpec_qual { (:) $1 $2 }
Spec_qual :: { Spec_qual }
Spec_qual : Type_specifier { Data.Gerber.Abs.TypeSpec $1 }
          | Type_qualifier { Data.Gerber.Abs.QualSpec $1 }
ListStruct_declarator :: { [Struct_declarator] }
ListStruct_declarator : Struct_declarator { (:[]) $1 }
                      | Struct_declarator ',' ListStruct_declarator { (:) $1 $3 }
Struct_declarator :: { Struct_declarator }
Struct_declarator : Declarator { Data.Gerber.Abs.Decl $1 }
                  | ':' Constant_expression { Data.Gerber.Abs.Field $2 }
                  | Declarator ':' Constant_expression { Data.Gerber.Abs.DecField $1 $3 }
Enum_specifier :: { Enum_specifier }
Enum_specifier : 'enum' '{' ListEnumerator '}' { Data.Gerber.Abs.EnumDec $3 }
               | 'enum' Ident '{' ListEnumerator '}' { Data.Gerber.Abs.EnumName $2 $4 }
               | 'enum' Ident { Data.Gerber.Abs.EnumVar $2 }
Enumerator :: { Enumerator }
Enumerator : Ident { Data.Gerber.Abs.Plain $1 }
           | Ident '=' Constant_expression { Data.Gerber.Abs.EnumInit $1 $3 }
Declarator :: { Declarator }
Declarator : Pointer Direct_declarator { Data.Gerber.Abs.BeginPointer $1 $2 }
           | Direct_declarator { Data.Gerber.Abs.NoPointer $1 }
Direct_declarator :: { Direct_declarator }
Direct_declarator : Ident { Data.Gerber.Abs.Name $1 }
                  | '(' Declarator ')' { Data.Gerber.Abs.ParenDecl $2 }
                  | Direct_declarator '[' Constant_expression ']' { Data.Gerber.Abs.InnitArray $1 $3 }
                  | Direct_declarator '[' ']' { Data.Gerber.Abs.Incomplete $1 }
                  | Direct_declarator '(' Parameter_type ')' { Data.Gerber.Abs.NewFuncDec $1 $3 }
                  | Direct_declarator '(' ListIdent ')' { Data.Gerber.Abs.OldFuncDef $1 $3 }
                  | Direct_declarator '(' ')' { Data.Gerber.Abs.OldFuncDec $1 }
ListIdent :: { [Ident] }
ListIdent : Ident { (:[]) $1 } | Ident ',' ListIdent { (:) $1 $3 }
Pointer :: { Pointer }
Pointer : '*' { Data.Gerber.Abs.Point }
        | '*' ListType_qualifier { Data.Gerber.Abs.PointQual $2 }
        | '*' Pointer { Data.Gerber.Abs.PointPoint $2 }
        | '*' ListType_qualifier Pointer { Data.Gerber.Abs.PointQualPoint $2 $3 }
ListType_qualifier :: { [Type_qualifier] }
ListType_qualifier : Type_qualifier { (:[]) $1 }
                   | Type_qualifier ListType_qualifier { (:) $1 $2 }
Parameter_type :: { Parameter_type }
Parameter_type : Parameter_declarations { Data.Gerber.Abs.AllSpec $1 }
               | Parameter_declarations ',' '...' { Data.Gerber.Abs.More $1 }
Parameter_declarations :: { Parameter_declarations }
Parameter_declarations : Parameter_declaration { Data.Gerber.Abs.ParamDec $1 }
                       | Parameter_declarations ',' Parameter_declaration { Data.Gerber.Abs.MoreParamDec $1 $3 }
Parameter_declaration :: { Parameter_declaration }
Parameter_declaration : ListDeclaration_specifier { Data.Gerber.Abs.OnlyType $1 }
                      | ListDeclaration_specifier Declarator { Data.Gerber.Abs.TypeAndParam $1 $2 }
                      | ListDeclaration_specifier Abstract_declarator { Data.Gerber.Abs.Abstract $1 $2 }
Initz :: { Initz }
Initz : Exp2 { Data.Gerber.Abs.InitExpr $1 }
      | '{' Initializers '}' { Data.Gerber.Abs.InitListOne $2 }
      | '{' Initializers ',' '}' { Data.Gerber.Abs.InitListTwo $2 }
Initializers :: { Initializers }
Initializers : Initz { Data.Gerber.Abs.AnInit $1 }
             | Initializers ',' Initz { Data.Gerber.Abs.MoreInit $1 $3 }
Type_name :: { Type_name }
Type_name : ListSpec_qual { Data.Gerber.Abs.PlainType $1 }
          | ListSpec_qual Abstract_declarator { Data.Gerber.Abs.ExtendedType $1 $2 }
Abstract_declarator :: { Abstract_declarator }
Abstract_declarator : Pointer { Data.Gerber.Abs.PointerStart $1 }
                    | Dir_abs_dec { Data.Gerber.Abs.Advanced $1 }
                    | Pointer Dir_abs_dec { Data.Gerber.Abs.PointAdvanced $1 $2 }
Dir_abs_dec :: { Dir_abs_dec }
Dir_abs_dec : '(' Abstract_declarator ')' { Data.Gerber.Abs.WithinParentes $2 }
            | '[' ']' { Data.Gerber.Abs.Array }
            | '[' Constant_expression ']' { Data.Gerber.Abs.InitiatedArray $2 }
            | Dir_abs_dec '[' ']' { Data.Gerber.Abs.UnInitiated $1 }
            | Dir_abs_dec '[' Constant_expression ']' { Data.Gerber.Abs.Initiated $1 $3 }
            | '(' ')' { Data.Gerber.Abs.OldFunction }
            | '(' Parameter_type ')' { Data.Gerber.Abs.NewFunction $2 }
            | Dir_abs_dec '(' ')' { Data.Gerber.Abs.OldFuncExpr $1 }
            | Dir_abs_dec '(' Parameter_type ')' { Data.Gerber.Abs.NewFuncExpr $1 $3 }
Stm :: { Stm }
Stm : Dec { Data.Gerber.Abs.DecS $1 }
    | Labeled_stm { Data.Gerber.Abs.LabelS $1 }
    | Compound_stm { Data.Gerber.Abs.CompS $1 }
    | Expression_stm { Data.Gerber.Abs.ExprS $1 }
    | Selection_stm { Data.Gerber.Abs.SelS $1 }
    | Iter_stm { Data.Gerber.Abs.IterS $1 }
    | Jump_stm { Data.Gerber.Abs.JumpS $1 }
Labeled_stm :: { Labeled_stm }
Labeled_stm : Ident ':' Stm { Data.Gerber.Abs.SlabelOne $1 $3 }
            | 'case' Constant_expression ':' Stm { Data.Gerber.Abs.SlabelTwo $2 $4 }
            | 'default' ':' Stm { Data.Gerber.Abs.SlabelThree $3 }
Compound_stm :: { Compound_stm }
Compound_stm : '{' ListStm '}' { Data.Gerber.Abs.ScompTwo (reverse $2) }
Expression_stm :: { Expression_stm }
Expression_stm : ';' { Data.Gerber.Abs.SexprOne }
               | Exp ';' { Data.Gerber.Abs.SexprTwo $1 }
Selection_stm :: { Selection_stm }
Selection_stm : 'if' '(' Exp ')' Stm { Data.Gerber.Abs.SselOne $3 $5 }
              | 'if' '(' Exp ')' Stm 'else' Stm { Data.Gerber.Abs.SselTwo $3 $5 $7 }
              | 'switch' '(' Exp ')' Stm { Data.Gerber.Abs.SselThree $3 $5 }
Iter_stm :: { Iter_stm }
Iter_stm : 'while' '(' Exp ')' Stm { Data.Gerber.Abs.SiterOne $3 $5 }
         | 'do' Stm 'while' '(' Exp ')' ';' { Data.Gerber.Abs.SiterTwo $2 $5 }
         | 'for' '(' Expression_stm Expression_stm ')' Stm { Data.Gerber.Abs.SiterThree $3 $4 $6 }
         | 'for' '(' Expression_stm Expression_stm Exp ')' Stm { Data.Gerber.Abs.SiterFour $3 $4 $5 $7 }
Jump_stm :: { Jump_stm }
Jump_stm : 'goto' Ident ';' { Data.Gerber.Abs.SjumpOne $2 }
         | 'continue' ';' { Data.Gerber.Abs.SjumpTwo }
         | 'break' ';' { Data.Gerber.Abs.SjumpThree }
         | 'return' ';' { Data.Gerber.Abs.SjumpFour }
         | 'return' Exp ';' { Data.Gerber.Abs.SjumpFive $2 }
Exp :: { Exp }
Exp : Exp ',' Exp2 { Data.Gerber.Abs.Ecomma $1 $3 } | Exp2 { $1 }
Exp2 :: { Exp }
Exp2 : Exp15 Assignment_op Exp2 { Data.Gerber.Abs.Eassign $1 $2 $3 }
     | Exp3 { $1 }
Exp3 :: { Exp }
Exp3 : Exp4 '?' Exp ':' Exp3 { Data.Gerber.Abs.Econdition $1 $3 $5 }
     | Exp4 { $1 }
Exp4 :: { Exp }
Exp4 : Exp4 '||' Exp5 { Data.Gerber.Abs.Elor $1 $3 } | Exp5 { $1 }
Exp5 :: { Exp }
Exp5 : Exp5 '&&' Exp6 { Data.Gerber.Abs.Eland $1 $3 } | Exp6 { $1 }
Exp6 :: { Exp }
Exp6 : Exp6 '|' Exp7 { Data.Gerber.Abs.Ebitor $1 $3 } | Exp7 { $1 }
Exp7 :: { Exp }
Exp7 : Exp7 '^' Exp8 { Data.Gerber.Abs.Ebitexor $1 $3 }
     | Exp8 { $1 }
Exp8 :: { Exp }
Exp8 : Exp8 '&' Exp9 { Data.Gerber.Abs.Ebitand $1 $3 }
     | Exp9 { $1 }
Exp9 :: { Exp }
Exp9 : Exp9 '==' Exp10 { Data.Gerber.Abs.Eeq $1 $3 }
     | Exp9 '!=' Exp10 { Data.Gerber.Abs.Eneq $1 $3 }
     | Exp10 { $1 }
Exp10 :: { Exp }
Exp10 : Exp10 '<' Exp11 { Data.Gerber.Abs.Elthen $1 $3 }
      | Exp10 '>' Exp11 { Data.Gerber.Abs.Egrthen $1 $3 }
      | Exp10 '<=' Exp11 { Data.Gerber.Abs.Ele $1 $3 }
      | Exp10 '>=' Exp11 { Data.Gerber.Abs.Ege $1 $3 }
      | Exp11 { $1 }
Exp11 :: { Exp }
Exp11 : Exp11 '<<' Exp12 { Data.Gerber.Abs.Eleft $1 $3 }
      | Exp11 '>>' Exp12 { Data.Gerber.Abs.Eright $1 $3 }
      | Exp12 { $1 }
Exp12 :: { Exp }
Exp12 : Exp12 '+' Exp13 { Data.Gerber.Abs.Eplus $1 $3 }
      | Exp12 '-' Exp13 { Data.Gerber.Abs.Eminus $1 $3 }
      | Exp13 { $1 }
Exp13 :: { Exp }
Exp13 : Exp13 '*' Exp14 { Data.Gerber.Abs.Etimes $1 $3 }
      | Exp13 '/' Exp14 { Data.Gerber.Abs.Ediv $1 $3 }
      | Exp13 '%' Exp14 { Data.Gerber.Abs.Emod $1 $3 }
      | Exp14 { $1 }
Exp14 :: { Exp }
Exp14 : '(' Type_name ')' Exp14 { Data.Gerber.Abs.Etypeconv $2 $4 }
      | Exp15 { $1 }
Exp15 :: { Exp }
Exp15 : '++' Exp15 { Data.Gerber.Abs.Epreinc $2 }
      | '--' Exp15 { Data.Gerber.Abs.Epredec $2 }
      | Unary_operator Exp14 { Data.Gerber.Abs.Epreop $1 $2 }
      | 'sizeof' Exp15 { Data.Gerber.Abs.Ebytesexpr $2 }
      | 'sizeof' '(' Type_name ')' { Data.Gerber.Abs.Ebytestype $3 }
      | Exp16 { $1 }
Exp16 :: { Exp }
Exp16 : Exp16 '[' Exp ']' { Data.Gerber.Abs.Earray $1 $3 }
      | Exp16 '(' ')' { Data.Gerber.Abs.Efunk $1 }
      | Exp16 '(' ListExp2 ')' { Data.Gerber.Abs.Efunkpar $1 $3 }
      | Exp16 '.' Ident { Data.Gerber.Abs.Eselect $1 $3 }
      | Exp16 '->' Ident { Data.Gerber.Abs.Epoint $1 $3 }
      | Exp16 '++' { Data.Gerber.Abs.Epostinc $1 }
      | Exp16 '--' { Data.Gerber.Abs.Epostdec $1 }
      | Exp17 { $1 }
Exp17 :: { Exp }
Exp17 : Ident { Data.Gerber.Abs.Evar $1 }
      | Constant { Data.Gerber.Abs.Econst $1 }
      | String { Data.Gerber.Abs.Estring $1 }
      | '(' Exp ')' { $2 }
Constant :: { Constant }
Constant : Double { Data.Gerber.Abs.Efloat $1 }
         | Char { Data.Gerber.Abs.Echar $1 }
         | Unsigned { Data.Gerber.Abs.Eunsigned $1 }
         | Long { Data.Gerber.Abs.Elong $1 }
         | UnsignedLong { Data.Gerber.Abs.Eunsignlong $1 }
         | Hexadecimal { Data.Gerber.Abs.Ehexadec $1 }
         | HexUnsigned { Data.Gerber.Abs.Ehexaunsign $1 }
         | HexLong { Data.Gerber.Abs.Ehexalong $1 }
         | HexUnsLong { Data.Gerber.Abs.Ehexaunslong $1 }
         | Octal { Data.Gerber.Abs.Eoctal $1 }
         | OctalUnsigned { Data.Gerber.Abs.Eoctalunsign $1 }
         | OctalLong { Data.Gerber.Abs.Eoctallong $1 }
         | OctalUnsLong { Data.Gerber.Abs.Eoctalunslong $1 }
         | CDouble { Data.Gerber.Abs.Ecdouble $1 }
         | CFloat { Data.Gerber.Abs.Ecfloat $1 }
         | CLongDouble { Data.Gerber.Abs.Eclongdouble $1 }
         | Integer { Data.Gerber.Abs.Eint $1 }
Constant_expression :: { Constant_expression }
Constant_expression : Exp3 { Data.Gerber.Abs.Especial $1 }
Unary_operator :: { Unary_operator }
Unary_operator : '&' { Data.Gerber.Abs.Address }
               | '*' { Data.Gerber.Abs.Indirection }
               | '+' { Data.Gerber.Abs.Plus }
               | '-' { Data.Gerber.Abs.Negative }
               | '~' { Data.Gerber.Abs.Complement }
               | '!' { Data.Gerber.Abs.Logicalneg }
ListExp2 :: { [Exp] }
ListExp2 : Exp2 { (:[]) $1 } | Exp2 ',' ListExp2 { (:) $1 $3 }
Assignment_op :: { Assignment_op }
Assignment_op : '=' { Data.Gerber.Abs.Assign }
              | '*=' { Data.Gerber.Abs.AssignMul }
              | '/=' { Data.Gerber.Abs.AssignDiv }
              | '%=' { Data.Gerber.Abs.AssignMod }
              | '+=' { Data.Gerber.Abs.AssignAdd }
              | '-=' { Data.Gerber.Abs.AssignSub }
              | '<<=' { Data.Gerber.Abs.AssignLeft }
              | '>>=' { Data.Gerber.Abs.AssignRight }
              | '&=' { Data.Gerber.Abs.AssignAnd }
              | '^=' { Data.Gerber.Abs.AssignXor }
              | '|=' { Data.Gerber.Abs.AssignOr }
ListExternal_declaration :: { [External_declaration] }
ListExternal_declaration : {- empty -} { [] }
                         | ListExternal_declaration External_declaration { flip (:) $1 $2 }
ListStruct_dec :: { [Struct_dec] }
ListStruct_dec : {- empty -} { [] }
               | ListStruct_dec Struct_dec { flip (:) $1 $2 }
ListEnumerator :: { [Enumerator] }
ListEnumerator : {- empty -} { [] }
               | Enumerator { (:[]) $1 }
               | Enumerator ',' ListEnumerator { (:) $1 $3 }
ListStm :: { [Stm] }
ListStm : {- empty -} { [] } | ListStm Stm { flip (:) $1 $2 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    t:_ -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

